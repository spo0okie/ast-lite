;; файл с организация-независимых макросов
;; макрос записи сообщения в отдельный лог
[macro-Msg]
exten => s,1,TrySystem(echo "${STRFTIME(${EPOCH},,%Y.%m.%d-%H:%M:%S)}	${ARG1}" >> ${Logfile})



;; макрос записи разовора в файл
[macro-RecordCall] ;; <record-suffix> <org_name>
exten => s,1,NoOp(Record call for org ${ARG2}:${RecordCalls_${ARG2}})
same => n,GotoIf($[ "${RecordCalls_${ARG2}}" != "yes" ]?Skip)
same => n,Set(__CallArrivedAt=${STRFTIME(${EPOCH},,%Y%m%d-%H%M%S)})
same => n,Set(__Recordfile=/home/record/${ARG2}/_current/${CallArrivedAt}-${CALLERID(num)}-${ARG1})
same => n,Set(__MONITOR_EXEC=/etc/asterisk/scripts/endrec.sh ${Recordfile})
same => n,Monitor(wav,${Recordfile},m)
same => n(Skip),NoOp()




;; макрос для попытки дозвониться до пира через основной сервер, если он недоступен, то вызвать через резервный
;;первый параметр - номер телефона
;;второй - удаленный транк, именно имя транка, чтобы мы могли опросить его статус (транк должен быть настроен на мониторинг)
;;третий - резервный транк, также имя транка, //local, если резервный путь - локальный сервер //context чтобы передать вызов в другой контекст в случае недоступности основного сервера
;;четвертый - в случае локального резервного вызова префикс организации, в случае перехода в другой контекст - имя контекста
;;в таком формате можно передать локальный сервер как резервный: SIP
[macro-FailoverCall] ;;<Phone_num> <Primary_server> <Failover path> <org prefix> //543 ast-chel SIP/mkh-asterisk org1
exten => s,1,GotoIf( $[ "${SIPPEER(${ARG2},status):0:2}" != "OK" ] ?Backup)
same => n,Dial(SIP/${ARG2}/${ARG1},${DialTime},${DialOpts})
same => n,Hangup
same => n(Backup),NoOp(Primary server ${ARG2} unreachable: Using ${ARG3} instead)
same => n,GotoIf( $[ "${ARG3}" = "local" ] ?local)
same => n,GotoIf( $[ "${ARG3}" = "context" ] ?context)
same => n(remote),Dial(SIP/${ARG3}/${ARG1},${DialTime},${DialOpts})
same => n,Hangup
same => n(local),Macro(Dial-Local,${ARG1},${ARG4},,)
same => n,Hangup
same => n(context),Dial(Local/${ARG1}@${ARG4})
same => n,Hangup




;;макрос подмены АОН для локального номера
[macro-CallerIDSubst] ;;<db_index>
;есть подмена CallerID в БД?
exten => s,1,NoOp(Searching for CallerID substitution)
same => n,GotoIf($[${DB_EXISTS(CallerID/${ARG1})} != 1]?return)
same => n,Set(CALLERID(num)=${DB(CallerID/${ARG1})})
same => n(return),MacroExit()




;;макрос начала вызова
;;пока только логирование начала вызова и подмена CallerID
[macro-newCall];; <org1> <Callee>
exten => s,1,GotoIf($[ ${LEN(${CallStartedAt})} > 0 ]?return)
same => n,NoOp(New call in ${ARG1}: ${CALLERID(num)} -> ${ARG2})
same => n,Set(__CallStartedAt=${STRFTIME(${EPOCH},,%Y%m%d-%H%M%S)})
same => n,Macro(CallerIDSubst,${ARG1}_${CALLERID(num)})
same => n(return),MacroExit()




;;макрос вызова локального номера (прям того который прям на этом сервере и может быть вызван через SIP/Num)
;;2017-04-18 добавлен третий параметр <local_trunk> для вызова "локальных" номеров через транк
;;например через местную АТС
[macro-Dial-Local] ;; <callee_number> <org_index> <local_trunk>
exten => s,1,Macro(Msg,Dial internal: ${CALLERID(num)} -> ${ARG1})

;есть подмена CallerID?
same => n,Macro(CallerIDSubst,${ARG2}_${CALLERID(num)})

;есть дублер (номер на котороый вызов должен продублироваться)?
same => n,GotoIf($[${DB_EXISTS(Dubler/${ARG2}_${ARG1})} != 1]?DialSingle)

;выставляем задержку вызова дублера на 0
same => n,Set(Delay=00)

;если СИП номер вызывается через транк, то его статус проверить невозможно, пропускаем проверку статуса
same => n,GotoIf( $[ "${ARG3}" != "" ] ?CkDupeDelay)
;если сам СИП номер не присутствует онлайн, то задержку не увеличиваем
same => n,GotoIf( $[ "${SIPPEER(${ARG1},status):0:2}" != "OK" ] ?DialDupe)

;СИП номер присутствует - задержка дублера может быть не 0, ищем в БД
same => n(CkDupeDelay),GotoIf($[${DB_EXISTS(DubDelay/${ARG2}_${ARG1})} != 1] ?DialDupe)
same => n,Set(Delay=${DB(DubDelay/${ARG2}_${ARG1})})
same => n(DialDupe),Dial(SIP/${ARG3}${ARG1}&Local/500${Delay}${DB(Dubler/${ARG2}_${ARG1})}@${ARG2}_service,${DialTime},${DialOpts})
same => n,Hangup()

;звоним на один номер, без дублирующих
same => n(DialSingle),Dial(SIP/${ARG3}${ARG1},${DialTime},${DialOpts})
same => n,Hangup()




[macro-Dial-SipTrunk]
;   ${ARG1} - Trunk;   ${ARG2} - Callee >
;; макрос вызова единичного транка
;; выставляем таймауты тонового меню (если надумаем делать переадресацию через астериск )
exten => s,1,Set(TIMEOUT(digit)=2)
same => n,Set(TIMEOUT(response)=4)

;; выставляем группу чтобы ее занять (способ отметить что транк занят)
same => n,Set(GROUP()=${ARG1})
;есть подмена CallerID для этого транка?
same => n,Macro(CallerIDSubst,${ARG1})
same => n,Dial(SIP/${ARG1}/${ARG2},${DialTime},${DialOpts})




;; макрос вызова пула из транков (транкпрефикс1, транкпрефикс2, ... транкпрефиксN)
[macro-Dial-SipPool]
;; ${ARG1} - OrgName; ${ARG2} - Callee; ${ARG3} - PoolPrefix; ${ARG4} - Pool length; ${ARG5} - reserv trunk

exten => s,1,Macro(Msg,Dial-SipPool: ${CALLERID(num)} -> ${ARG2} over pool ${ARG3}N)

;; записываем звонок если это надо
same => n,Macro(RecordCall,OUT-${ARG2},${ARG1})

;; начинаем с первого транка
same => n,Set(Num=1)
same => n(Next),Set(callchan=${ARG3}${Num})

;; по умолчанию транк безлимитный (999 линий)
same => n,Set(TrunkLimit=999)

;; но это может быть переопределено в базе данных
same => n,GotoIf($[${DB_EXISTS(TrunkLimit/${callchan})} != 1] ?TLimCheck)
same => n,Set(TrunkLimit=${DB(TrunkLimit/${callchan})})

;; проверяем не превышено ли количество линий
same => n(TLimCheck),GotoIf($[${GROUP_COUNT(${callchan})} > ${TrunkLimit}]?Busy)


;; САМ ВЫЗОВ ТУТ
same => n,Macro(Dial-SipTrunk,${callchan},${ARG2})
;; если код окончания вызова - недоступность канала, то пробуем следующий транк
same => n,NoOp(${DIALSTATUS}/${HANGUPCAUSE})
;;Перечисляем причины нормального отбоя (иначе будет совершена попытка вызова через следующий транк) (http://wiki.merionet.ru/ip-telephoniya/31/hangupcause-v-asterisk-ih-znacheniya/)
same => n,GotoIf($["${HANGUPCAUSE}"="16"]?Busy)		;16	BYE	Normal call clearing - вызов был закончен естественным образом (кто - то из абонентов положил трубку)
same => n,GotoIf($["${HANGUPCAUSE}"="17"]?Busy)		;17	486	User busy - индицирует, что вызываемый абонент не может принять вызов, так как находится в состоянии "Занят" (есть активный разговор)
same => n,GotoIf($["${HANGUPCAUSE}"="18"]?Busy)		;18	480	No user responding - вызываемый абонент не ответил на сообщение о вызове (инициации) в течение определенного времени
same => n,GotoIf($["${HANGUPCAUSE}"="19"]?Busy)		;19	480	T.301 expired: – User Alerted, No answer from user - аппарат вызываемого абонента звонил, но он не ответил на звонок
same => n,GotoIf($["${HANGUPCAUSE}"="23"]?Busy)		;23	—  	Reverse charging rejected - вариант, когда за звонок платит принимающая вызов сторона. Данное сообщение обозначает отклонение такого вызова.
same => n,GotoIf($["${HANGUPCAUSE}"="24"]?Busy)		;24	—	Call suspended - оборудование получило запрос на приостановку вызова
same => n,GotoIf($["${HANGUPCAUSE}"="25"]?Busy)		;25	—	Call resumed - вызов возобновлен (продолжение 24 отбоя)

same => n,Set(Num=$[ ${Num} + 1 ])
;; проверка что транки в пуле закончились
same => n,GotoIf($[ ${Num} > ${ARG4} ]?ResTrunk)
same => n,Goto(Next)

;; пытаемся вызвать резервный транк
same => n(ResTrunk),Macro(Msg,"POOLFULL:${ARG3} --> ${ARG2}")
same => n,Macro(${ARG5},${ARG1},${ARG2})
same => n(Busy),Hangup()




;; Это вроде как просто исходящий вызов наружу 
;; через конкретный транк с конкретным внешним CallerID
[macro-DialOut-Simple] ; <org1> <Callee> <Trunk> <extCallerID>
exten => s,1,Macro(newCall,${ARG1},${ARG2})
same => n,Macro(Msg,Outgoing_call: ${CALLERID(num)} over ${ARG3}/${ARG4} -> ${ARG2})
same => n,Macro(RecordCall,OUT-${ARG2},${ARG1})
same => n,Set(CALLERID(all)=${ARG4})
same => n,Macro(Dial-SipTrunk,${ARG3},${ARG2})




;;макрос записи wav файлов - сообщений
[macro-recordMessage] ;;<org> <message-name>
exten => s, 1, Playback(beep)
same => n, Playback(beep)
same => n, Record(/var/lib/asterisk/sounds/${ARG1}/${ARG2}.wav)
same => n, Wait(2)
same => n, Playback(/var/lib/asterisk/sounds/${ARG1}/${ARG2})
same => n, Hangup()




;;макрос прослушивания wav файлов - сообщений
[macro-playMessage] ;;<org> <message-name>
exten => s, 1, Playback(/var/lib/asterisk/sounds/${ARG1}/${ARG2})
same => n, Hangup()
